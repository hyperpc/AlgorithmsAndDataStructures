# 排序：为混乱带来秩序

当数据集规模较大，仅靠数据结构已经无法满足效率的提升，排序成为一种选择  

将数据列表或数据集中的元素，按照特定的值或值的集合，组织起来的方式，称为排序sorting  

如果待排序元素的数据结构较复杂，一般会分出参与排序的主键(Primary Key)，辅键(Secondary Key)，三级键(Tertiary Key)和四级键(Quaternary Key)  

不同排序算法，适用不同规模或不同类型的排序问题；而每种排序算法往往只适用于特定类型的数据结构  

## 选择排序

选择排序selection sort，原地比较算法；算法复杂度O(n<sup>2</sup>)，速度最慢，且最低效的排序算法  

- 给定一个集合：S={50,25,73,21,3}  
- 首先找出S中的最小值3，并置于S的顶端：S={3,25,73,21,50}  
- 然后，在S上重复进行上述过程，得到21：S={3,21,73,25,50}  
- 然后，在S上重复进行上述过程，得到25：S={3,21,25,73,50}  
- 然后，在S上重复进行上述过程，得到50：S={3,21,25,50,73}  
- 这里，不需要对最后一个元素进行排序，它已经是经过比较后，留下来的最大值  

> 循环的嵌套：  
> 嵌套循环的算法，会指数性的增加算法复杂度。任何一个for循环的复杂度为O(n)；  
> 嵌套多一层，复杂度为O(n<sup>2</sup>)；在多一层，复杂度为O(n<sup>3</sup>)  
> 以此类推，复杂度会越来越恐怖。故不到万不得已，不要嵌套for循环  

## 插入排序

插入排序insertion sort，访问数据集中的对象，并将其键值，与之前的对象键值比较。如果原数据集是排好序的，此算法效率有极大提升  

- 给定一个集合：S={50,25,73,21,3}  
- 从i=1开始排序，因为i=0的时候，i-1会报越界异常  
- i=1，25小于50，二者互换位置：S={25,50,73,21,3}  
- i=2，50小于73，不需要任何操作：S={25,50,73,21,3}  
- i=3，73大于21，二者互换位置：S={25,50,21,73,3}；继续向左比较，21和前面的元素依次比较，3被换至位置0处：S={21,25,50,73,3}    
- i=4，73大于3，二者互换位置：S={21,25,50,73,3}；继续向左比较，3和前面的元素依次比较，3被换至位置0处：S={3,21,25,50,73}  
- 循环结束    

> 此算法虽然简便，但数据集元素较多时，复杂度依然较高。  
> 如果原数据集未曾排序，复杂度依然为O(n<sup>2</sup>)；  
> 如果原数据集已经排好序，复杂度最优可提升为O(n)，稍优于选择排序  

## 冒泡排序

冒泡排序bubble sort，又叫沉没排序sinking sort。逐步访问列表中存储的数值或对象，并比较两个相邻元素的键值，判断顺序。  
总体来说，该排序仍然比较低效。与其他比较排序算法的优势为，其工作机制能隐含地判断出当前列表是否已完成排序。  

- 给定一个集合：S={50,25,73,21,3}  
- 第一次循环，先比较{i=0, i=1}两个元素，50大于25，互换位置；然后比较{i=1, i=2}两个元素，50小于73，不需要操作；继续比较{i=2, i=3}两个元素，73大于21，互换位置；最后比较{i=3, i=4}两个元素，73大于3，互换位置；本轮结束，比较结构：S={25,50,21,3,73}  
- 第二次循环，先比较{i=0, i=1}两个元素，25小于50，不需要操作；然后比较{i=1, i=2}两个元素，50大于21，互换位置；继续比较{i=2, i=3}两个元素，50大于3，互换位置；而{i=3, i=4}两个元素，上一轮已经参与比较，本轮循环停止；本轮结束，比较结构：S={25,21,3,50,73}  
- 第三次循环，先比较{i=0, i=1}两个元素，25大于21，互换位置；然后比较{i=1, i=2}两个元素，25大于3，互换位置；剩余的{i=2, i=3}两个元素，和{i=3, i=4}两个元素，上一轮已经参与比较，本轮循环停止；本轮结束，比较结构：S={21,3,25,50,73}  
- 第三次循环，先比较{i=0, i=1}两个元素，21大于3，互换位置；剩余的{i=1, i=2}两个元素，和{i=2, i=3}两个元素，和{i=3, i=4}两个元素，上一轮已经参与比较，本轮循环停止；本轮结束，比较结构：S={3,21,25,50,73}  

> 以上表明，每次循环都有n-j次比较，n为集合元素数量，j为当前循环序数。每次循环结束，效率都有细微提升。  
> 最坏算法复杂度O(n<sup>2</sup>)；当将排序操作限制在未排序的对象集合中时，算法复杂度提升为O(n)，与插入排序相当，略优于选择排序；  
> 某些情况下，如果列表已经排序，冒泡排序效率甚至略高于下面的快速排序。  
> 总体而言，冒泡排序仍然低效，只适用于小规模对象数据集的排序。  

## 快速排序

快速排序quick sort，基于“分而治之(Divide-and-conquer)”策略；递归地将集合分为两个或两个以上的子集，直到每个子集问题规模都变得简单，从而可以直接求解。  
该算法，先从数据集跳出一个基准(pivot)元素；然后，将所有小于该基准的元素，移动到基准之前，大于基准的元素，移动到基准之后，此过程称为分区(partition)；  
此后，分区操作会递归地在不断缩小的子集上重复执行，直至机子中剩下0到1个元素，从而完成排序。

正确选择基准点，可以有效提升排序性能；如果选择的基准刚好是最大或最小元素，快速排序的复杂度就是O(n)。  

基准点选择方法：

- 总是选择数据集的第一个元素为基准点  
- 总是选择数据集的中间元素为基准点  
- 总是选择数据集的最后一个元素为基准点(参考示例代码)  
- 从数据集中随机选择一个元素为基准点  

快速排序的最坏复杂度和前面的排序方法一样，都是O(n<sup>2</sup>)；但平均复杂度和最优情况复杂度都有提升，为O(nlog(n))  

## 归并排序

归并排序merge sort，另一种常用的基于分而治之策略的高效排序算法  

将数据集对半分割，并再每个子集上递归排序，最后，将排好的子集，进行比较后合并，故称为归并排序。  
该算法进一步重复分割子集，直到每个子集只有一个对象，并根据定义排序；然后比较这些对象，确定合并的顺序。  
算法的最坏复杂度、平均复杂度和最优复杂度均为O(nlog(n))。最坏复杂度优于快速排序。  

## 桶排序

桶排序bucket sort，又叫箱排序，一种分布式排序算法。  

分布式脾虚，会先将原数据集分解为某种形式的中间数据结构，再将数据排序、组织，最后合并成要输出的数据结构。  

桶排序，会根据元素的数值或数值范围，分布到多个数组，每个数组就是对应的`桶`；每个桶依然会通过比较排序整理元素顺序。  

使用数组表示桶，使用原数据集中的值表示桶的索引。这也是算法更快的关键。  
最坏情况的算法复杂度为O(n<sup>2</sup>)；最优情况的复杂度为O(n+k)，n为原数组元素总数，k为参与排序的桶的数量  

## 计数排序

计数排序counting sort，是一种更高效的分布式排序，但不能良好的适用于所有情况  
